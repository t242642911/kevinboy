<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迴廊低語 - 恐怖文字遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* 恐怖驚悚風格的色彩和字體變數 */
        :root {
            --bg-color: #1a1a1a; /* 深灰近黑背景 */
            --card-bg: #2d2d2d;  /* 深灰卡片背景 */
            --text-primary: #cccccc; /* 卡片亮色 - 淺灰 */
            --text-secondary: #888888;/* 卡片次要文字 - 中灰 */
            --text-dark: #e0e0e0;   /* 頁面主要文字 - 亮灰 */
            --accent-red: #9f1f1f;   /* 暗血紅 */
            --accent-red-dark: #7a1010;
            --accent-blue: #3b5998;  /* 陰鬱藍 (少量使用) */
            --accent-blue-dark: #2a3f6f;
            --accent-gray: #555555; /* 深灰 */
            --accent-gray-dark: #333333;

            --keyword-blue: var(--accent-red); /* 關鍵字用紅色 */
            --keyword-red: #d04f4f; /* 選項關鍵字用稍亮的紅色 */
            --tag-border: #444444;  /* 標籤邊框 - 深灰 */
            --tag-text: #999999;   /* 標籤文字 - 灰色 */
            --shadow-color-light: rgba(0, 0, 0, 0.2); /* 陰影 - 更深 */
            --shadow-color-medium: rgba(0, 0, 0, 0.3);
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        body {
            font-family: 'Noto Serif TC', serif; /* 恐怖遊戲用襯線體可能更有感覺 */
            overscroll-behavior: none;
            background-color: var(--bg-color);
            font-size: 16px;
            color: var(--text-dark);
        }
        #game-container { min-height: 100vh; display: flex; flex-direction: column; }

        /* 關鍵字高亮 */
        .keyword { color: var(--keyword-blue); font-weight: bold; font-style: italic; } /* 關鍵字也用斜體 */
        .choice-keyword { color: var(--keyword-red); font-weight: bold; }

        /* 標題樣式 */
        .game-title-gradient {
            font-family: 'Noto Serif TC', serif; /* 保持襯線 */
            color: var(--accent-red);
            text-shadow: 1px 1px 5px rgba(159, 31, 31, 0.5); /* 紅色陰影 */
            filter: none;
            background: none;
            -webkit-background-clip: unset; background-clip: unset;
        }
        .chapter-title-style {
            font-family: 'Noto Serif TC', serif;
            color: #a0a0a0; /* 標題用灰色 */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            font-size: 1.75rem; /* 稍微小一點 */
            letter-spacing: 1px; /* 增加字距 */
        }

        /* 對話框樣式 - 修改為更壓抑的風格 */
        .dialogue-box {
            border: 1px solid #444; padding: 1.1rem; margin-bottom: 1.1rem;
            border-radius: 4px; /* 更銳利些 */
            background-color: rgba(45, 45, 45, 0.92); /* 深灰背景 */
            box-shadow: 0 4px 12px var(--shadow-color-medium);
            line-height: 1.8; font-size: 1.05rem; /* 稍微小一點 */
            animation: fadeIn 0.8s ease-out; /* 淡入慢一點 */
            position: relative;
            padding-right: 3rem;
            color: var(--text-primary); /* 主要文字用淺灰 */
        }
        .dialogue-box.player { border-left: 5px solid var(--accent-red); } /* 玩家用紅色邊框 */
        .dialogue-box.npc { border-left: 5px solid var(--accent-gray); } /* NPC 用灰色邊框 */
        .character-name { font-weight: bold; margin-bottom: 0.6rem; font-size: 1.1rem; letter-spacing: 0.5px; }
        .dialogue-box.player .character-name { color: var(--accent-red); } /* 玩家名字用紅色 */
        .dialogue-box.npc .character-name { color: #aaaaaa; } /* NPC 名字顏色 */
        .dialogue-box.italic { font-style: italic; color: #b0b0b0; } /* 旁白斜體顏色 */


        /* 播放按鈕樣式 - 降低飽和度 */
        .speak-button {
            position: absolute; top: 0.75rem; right: 0.75rem; background: none;
            border: none; font-size: 1.4rem; cursor: pointer; color: #777; /* 更暗的灰色 */
            transition: color 0.2s ease, transform 0.2s ease; padding: 0.25rem; line-height: 1;
        }
        .speak-button:hover { color: #ccc; transform: scale(1.1); }
        .speak-button:active { transform: scale(0.95); }
        .speak-button.speaking { color: #ccc; animation: pulse 1.5s infinite ease-in-out; }
        .speak-button.paused { color: #aaa; }

        /* 按鈕樣式 - 使用更陰沉的配色 */
        .btn { display: inline-block; padding: 0.8rem 1.6rem; margin: 0.5rem; border-radius: 4px; background-image: linear-gradient(to right, var(--accent-gray-dark), #222); color: #ccc; border: 1px solid #555; text-align: center; cursor: pointer; transition: all 0.3s ease; font-weight: normal; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); font-size: 1rem; }
        .btn:hover { background-image: linear-gradient(to right, #222, #111); color: #fff; border-color: #777; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); transform: translateY(-2px); }
        .btn:active { transform: translateY(0px); box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3); }
        .btn-secondary { background-image: linear-gradient(to right, #555, #444); border-color: #777; }
        .btn-secondary:hover { background-image: linear-gradient(to right, #444, #333); border-color: #999; }
        /* 紅色按鈕用於危險或關鍵抉擇 */
        .btn-danger { background-image: linear-gradient(to right, var(--accent-red), var(--accent-red-dark)); border-color: #c85e5e; color: white; }
        .btn-danger:hover { background-image: linear-gradient(to right, var(--accent-red-dark), #7a1010); border-color: #f08080; }
        .btn-disabled { background-image: none; background-color: #333; color: #666; border-color: #444; cursor: not-allowed; box-shadow: none; transform: none; }
        .btn-small { padding: 5px 10px; font-size: 0.875rem; margin: 0; }
        .btn-select-char { width: 100%; margin-top: auto; padding: 0.7rem 1rem; font-size: 0.95rem;}

        /* 開始畫面資訊文字 */
        .start-info-text { font-size: 1.1rem; color: #aaa; margin-bottom: 0.6rem; }
        .start-info-text span { font-weight: bold; color: #ccc; }

        /* 角色卡片樣式 - 使用暗色主題 */
        #character-options { display: flex; flex-direction: column; gap: 1.75rem; width: 100%; max-width: 650px; margin: 0 auto; padding-bottom: 3rem; }
        .character-card {
            background-color: var(--card-bg); border-radius: 6px; padding: 0; margin: 0;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2), 0 3px 6px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease, border 0.3s ease;
            cursor: pointer; border: 1px solid #444; /* 邊框 */
            display: flex; overflow: hidden; align-items: stretch;
        }
        .character-card:hover { transform: translateY(-5px); box-shadow: 0 12px 25px rgba(0, 0, 0, 0.3), 0 5px 10px rgba(0, 0, 0, 0.2); border-color: #666; }
        .character-card.selected { border-color: var(--accent-red); box-shadow: 0 10px 20px rgba(159, 31, 31, 0.2), 0 4px 8px rgba(159, 31, 31, 0.15); } /* 選中用紅色 */
        .character-image-container { flex-shrink: 0; width: 160px; filter: grayscale(0.5) brightness(0.9); transition: filter 0.3s ease;} /* 圖片灰度降低亮度 */
        .character-card:hover .character-image-container { filter: grayscale(0.2) brightness(1); }
        .character-image-container img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .character-info-container { flex-grow: 1; padding: 1.5rem 1.75rem; display: flex; flex-direction: column; color: var(--text-secondary); }
        .character-info-container h3 { font-family: 'Noto Serif TC', serif; font-size: 1.4rem; font-weight: bold; color: var(--text-primary); margin-bottom: 0.8rem; text-align: left; }
        .character-description { font-size: 0.95rem; line-height: 1.7; color: var(--text-secondary); font-weight: normal; margin-bottom: 1.2rem; text-align: left; flex-grow: 1; }
        .character-tags { display: flex; flex-wrap: wrap; gap: 0.7rem; margin-bottom: 1.5rem; justify-content: flex-start; }
        /* 標籤樣式 */
        .keyword-tag-box {
            background-color: rgba(255, 255, 255, 0.05); color: var(--tag-text);
            padding: 5px 12px; border: 1px solid var(--tag-border); border-radius: 4px;
            font-size: 0.8rem; font-weight: normal; white-space: nowrap;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }
        .keyword-tag-box:hover { background-color: rgba(255, 255, 255, 0.1); color: #bbb; border-color: #666; }

        /* Modal 彈出視窗樣式 - 暗色主題 */
        .modal {
            visibility: hidden; opacity: 0; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%; overflow: auto;
            background-color: rgba(10, 10, 10, 0.85); /* 更深的背景 */
            transition: opacity 0.4s ease-out, visibility 0.4s ease-out;
        }
        .modal.active { visibility: visible; opacity: 1; }
        .modal-content {
            background-color: #252525; /* Modal 背景色 */
            color: var(--text-primary); /* Modal 文字顏色 */
            padding: 25px; border: 1px solid #555; /* 邊框 */
            border-radius: 6px; position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0, 0.4);
            width: 90%;
            transform: scale(0.95) translateY(-10px); opacity: 0;
            transition: opacity 0.3s ease-out 0.1s, transform 0.3s ease-out 0.1s;
        }
        .modal.active .modal-content { transform: scale(1) translateY(0); opacity: 1; }

        /* 筆記本 Modal */
        #notebook-modal .modal-content { margin: 10% auto; max-width: 600px; }
        #notebook-modal h3 { color: #ddd; border-bottom: 1px solid #555; padding-bottom: 0.5rem; }
        #clue-list li { margin-bottom: 0.75rem; font-size: 1.05rem; color: #bbb; } /* 線索文字顏色 */

        /* 設定 Modal */
        #settings-modal .modal-content { position: absolute; top: 4rem; right: 1rem; margin: 0; max-width: 350px; width: auto; }
        #settings-modal h3 { color: #ddd; border-bottom: 1px solid #555; padding-bottom: 0.5rem; }
        .settings-controls-grid { display: grid; gap: 0.75rem; }
        .settings-group label { color: #bbb; width: 50px; text-align: right; flex-shrink: 0;}
        /* Range slider */
        .settings-group input[type="range"] { background-color: #444; border: 1px solid #666;}
        .settings-group input[type="range"]::-webkit-slider-runnable-track { background: #666; }
        .settings-group input[type="range"]::-moz-range-track { background: #666; }
        .settings-group input[type="range"]::-webkit-slider-thumb { background: var(--accent-red); }
        .settings-group input[type="range"]::-moz-range-thumb { background: var(--accent-red); }
        /* Select dropdown */
        .settings-group select {
             border: 1px solid #666; background-color: #333; color: #ccc;
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); /* 淺色箭頭 */
        }
        .settings-group span#settings-speed-display { color: #111; background-color: #888; } /* 速度顯示 */
        .modal-close-button { color: #888; }
        .modal-close-button:hover, .modal-close-button:focus { color: #ccc; }

        /* 場景背景 - 更暗的遮罩 */
        .scene-background { background-size: cover; background-position: center; min-height: 100vh; transition: background-image 1s ease-in-out; position: relative; display: flex; flex-direction: column; width: 100%; }
        .scene-background::before { content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 1; transition: background-color 0.5s ease; } /* 預設遮罩 */
        .scene-content { position: relative; z-index: 2; flex-grow: 1; display: flex; flex-direction: column; //justify-content:  flex-start; }

        /* 設定按鈕樣式 - 暗色主題 */
        .settings-button-container { position: absolute; top: 1rem; right: 1rem; z-index: 60; }
        .settings-button { background-color: rgba(50, 50, 50, 0.8); border: 1px solid #666; border-radius: 50%; padding: 0.6rem; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0, 0.3); transition: background-color 0.2s ease, transform 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .settings-button:hover { background-color: rgba(70, 70, 70, 0.9); transform: scale(1.1); }
        .settings-icon { font-size: 1.3rem; color: #ccc; line-height: 1; }

        /* 動畫 */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in { animation: fadeIn 0.8s ease-out forwards; } /* 持續時間加長 */
        #story-display > .dialogue-box, #choices-display > .btn { opacity: 0; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } } /* 脈衝幅度減小 */
        @keyframes subtleFlicker { /* 細微閃爍動畫 */
          0% { opacity: 1; } 49% { opacity: 1; } 50% { opacity: 0.97; } 51% { opacity: 1; } 100% { opacity: 1; }
        }


        /* 響應式設計調整 */
        @media (max-width: 768px) {
            body { font-size: 15px; }
             .modal-content { width: 90%; padding: 20px; }
             #notebook-modal .modal-content { margin: 15% auto; max-width: 90%;}
             #settings-modal .modal-content { top: 3.5rem; right: 0.5rem; max-width: calc(100% - 1rem); width: auto; }
             #character-options { max-width: 95%; gap: 1rem; padding-bottom: 1rem; }
             .character-card { flex-direction: column; }
             .character-image-container { width: 100%; height: 180px; }
             .character-info-container { padding: 1rem; }
             .character-description { font-size: 0.9rem; }
             .dialogue-box { font-size: 1rem; padding-right: 2.5rem; }
             .speak-button { font-size: 1.3rem; top: 0.5rem; right: 0.5rem; }
             .btn { padding: 0.6rem 1.2rem; font-size: 0.95rem;}
             .settings-button-container { top: 0.5rem; right: 0.5rem; }
             .settings-button { padding: 0.5rem; }
             .settings-icon { font-size: 1.1rem; }
             .settings-group label { width: 40px; font-size: 0.8rem;}
             .settings-group input[type="range"] { min-width: 80px; }
             .settings-group select { min-width: 120px; font-size: 0.8rem;}
             .settings-group .btn-small { font-size: 0.75rem;}
             .settings-group span#settings-speed-display { font-size: 0.75rem; min-width: 35px;}

        }
        @media (max-width: 480px) {
             body { font-size: 14px; }
             .character-image-container { height: 150px; }
             .character-info-container h3 { font-size: 1.2rem;}
             .character-description { font-size: 0.85rem; }
             .keyword-tag-box { font-size: 0.75rem; padding: 4px 10px;}
             .btn-select-char { font-size: 0.9rem;}
             .dialogue-box { font-size: 0.95rem; }
             .btn { padding: 0.5rem 1rem; font-size: 0.9rem; }
             #settings-modal .modal-content { max-width: calc(100% - 1rem); }
             .settings-group label { width: 35px; }
             .settings-group .control-container { gap: 0.25rem; }
             .settings-group select { min-width: 100px; }
        }

         /* 日夜變化遮罩 */
        .time-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(10, 10, 20, 0.4); /* 預設偏藍的暗色 */
            z-index: 1; pointer-events: none;
            transition: background-color 0.8s ease-in-out;
        }
    </style>
</head>
<body class="text-gray-800"> <div id="game-container" class="container mx-auto p-0 md:p-4 max-w-none md:max-w-4xl min-h-screen flex flex-col">

        <div class="settings-button-container">
            <button id="open-settings-button" class="settings-button" title="遊戲設定">
                <span class="settings-icon">⚙️</span>
            </button>
        </div>

        <div id="start-screen" class="flex flex-col items-center  flex-grow scene-background" style="">
            <div class="scene-content text-center p-4">
                <div class="bg-black bg-opacity-80 p-8 md:p-10 rounded-lg shadow-xl text-white max-w-xl mx-auto border border-gray-700">
                    <h1 class="text-5xl font-bold mb-6 game-title-gradient">迴廊低語</h1>
                    <p class="mb-3 text-lg leading-relaxed">頭痛欲裂... 你在一張冰冷的鐵床上醒來，四周是斑駁的牆壁和刺鼻的<span class="keyword">消毒水</span>氣味。這裡是哪裡？窗外一片漆黑，只有<span class="keyword">風聲</span>嗚咽。</p>
                    <p class="mb-6 text-lg leading-relaxed">你發現手邊有一張<span class="keyword">皺巴巴的紙條</span>，上面似乎寫著什麼... 你必須想辦法離開這個不祥之地。<span title="Fear">😨</span></p>
                    <div class="text-gray-400 mb-8 space-y-2">
                        <p class="start-info-text">建議遊玩人數：<span>1</span> 人</p>
                        <p class="start-info-text">預計總時長：約 <span>20-30</span> 分鐘</p>
                        <p class="start-info-text">恐怖指數：<span>★★★☆☆</span> (中等)</p>
                    </div>
                    <button id="start-game-button" class="btn text-lg btn-danger">掙扎醒來</button>
                    <button id="load-game-button" class="btn btn-secondary text-lg mt-2 md:mt-0 md:ml-4 hidden">讀取記憶</button>
                </div>
            </div>
        </div>

        <div id="character-select-screen" class="hidden flex flex-col items-center  flex-grow scene-background" style="">
             <div class="scene-content w-full flex flex-col items-center p-4">
                 <h2 class="text-3xl font-bold mb-8 text-center text-gray-100 chapter-title-style">你是誰？(可選)</h2>
                 <div id="character-options" class="flex flex-col gap-6 w-full max-w-lg"></div>
                 <p class="text-center mt-8 text-gray-400">(如果只有單一主角，此畫面可以不使用)</p>
             </div>
        </div>

        <div id="game-screen" class="hidden flex flex-col flex-grow scene-background" style="">
            <div class="scene-content flex-grow flex flex-col p-4 md:p-6">
                <div class="bg-black bg-opacity-85 p-4 md:p-6 rounded-lg shadow-lg flex-grow flex flex-col max-w-4xl mx-auto w-full border border-gray-800">
                    <h2 id="chapter-title" class="text-2xl font-bold mb-4 text-white text-center chapter-title-style"></h2>
                    <div id="character-status" class="mb-4 p-3 bg-gray-800 bg-opacity-90 rounded-lg flex items-center shadow border border-gray-700">
                        <img id="player-avatar-game" src="" alt="角色頭像" class="w-12 h-12 rounded-md mr-4 border-2 border-red-800 shadow-md filter grayscale(0.3)">
                        <div class="flex-grow">
                            <p id="player-name-game" class="font-bold text-gray-300"></p>
                            <p id="current-objective" class="text-sm text-gray-500"></p>
                        </div>
                         <button id="notebook-button" class="btn btn-secondary ml-4">查看筆記 <span title="Notes">📝</span></button>
                         <button id="save-game-button" class="btn btn-secondary ml-2">保存記憶 <span title="Save">💾</span></button>
                    </div>
                    <div id="story-display" class="flex-grow overflow-y-auto mb-4 p-4 bg-gray-900 bg-opacity-95 rounded-lg shadow-inner min-h-[300px] max-h-[55vh] border border-gray-700"></div>
                    <div id="choices-display" class="mt-auto text-center"></div>
                </div>
            </div>
        </div>

        <div id="ending-screen" class="hidden flex flex-col items-center  flex-grow scene-background" style="">
            <div class="scene-content text-center p-4">
                <div class="bg-gray-900 bg-opacity-95 p-8 md:p-10 rounded-lg shadow-xl max-w-lg mx-auto border border-red-900">
                    <h2 id="ending-title" class="text-4xl font-bold mb-6 text-red-500"></h2>
                    <p id="ending-description" class="mb-8 text-gray-400 leading-relaxed"></p>
                    <button id="restart-button" class="btn text-lg btn-danger">重新開始 <span title="Restart">🔄</span></button>
                </div>
            </div>
        </div>

        <div id="notebook-modal" class="modal">
            <div class="modal-content">
                <span class="modal-close-button" onclick="closeNotebook()">&times;</span>
                <h3 class="text-xl font-bold mb-4">筆記 <span title="Notes">📝</span></h3>
                <ul id="clue-list" class="list-disc list-inside space-y-2">
                    <li>這裡空空如也...</li>
                </ul>
            </div>
        </div>

        <div id="settings-modal" class="modal">
            <div class="modal-content">
                <span class="modal-close-button" onclick="closeSettings()">&times;</span>
                <h3 class="text-xl font-bold mb-6 text-center">設定 ⚙️</h3>
                <div class="settings-controls-grid">
                     <div class="settings-group">
                         <label for="settings-volume-slider">音量:</label>
                         <div class="control-container">
                             <input type="range" id="settings-volume-slider" min="0" max="1" step="0.1" value="0.5">
                             <button id="settings-mute-button" class="btn btn-secondary btn-small">靜音</button>
                         </div>
                    </div>
                    <div class="settings-group speed-control">
                         <label for="settings-speed-display">速度:</label>
                         <div class="control-container">
                             <button id="settings-speed-down-button" class="btn btn-secondary btn-small">-</button>
                             <span id="settings-speed-display">x1.0</span>
                             <button id="settings-speed-up-button" class="btn btn-secondary btn-small">+</button>
                         </div>
                    </div>
                    <hr class="my-2 border-gray-700 col-span-full"> <div class="settings-group">
                         <label for="settings-tts-voice">語音:</label>
                         <div class="control-container">
                             <select id="settings-tts-voice" name="tts-voice"></select>
                         </div>
                    </div>
                    <div class="settings-group">
                         <label for="settings-tts-rate">語速:</label>
                         <div class="control-container">
                             <input type="range" id="settings-tts-rate" min="0.5" max="2" step="0.1" value="1">
                         </div>
                    </div>
                    <div class="settings-group">
                         <label for="settings-tts-pitch">音高:</label>
                         <div class="control-container">
                             <input type="range" id="settings-tts-pitch" min="0" max="2" step="0.1" value="1">
                         </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- DOM 元素獲取 ---
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen');
        const characterSelectScreen = document.getElementById('character-select-screen');
        const gameScreen = document.getElementById('game-screen');
        const endingScreen = document.getElementById('ending-screen');
        const startGameButton = document.getElementById('start-game-button');
        const characterOptionsContainer = document.getElementById('character-options');
        const chapterTitle = document.getElementById('chapter-title');
        const storyDisplay = document.getElementById('story-display');
        const choicesDisplay = document.getElementById('choices-display');
        const endingTitle = document.getElementById('ending-title');
        const endingDescription = document.getElementById('ending-description');
        const restartButton = document.getElementById('restart-button');
        const playerAvatarGame = document.getElementById('player-avatar-game');
        const playerNameGame = document.getElementById('player-name-game');
        const currentObjective = document.getElementById('current-objective');
        const notebookButton = document.getElementById('notebook-button');
        const notebookModal = document.getElementById('notebook-modal');
        const clueList = document.getElementById('clue-list');
        const openSettingsButton = document.getElementById('open-settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const settingsVolumeSlider = document.getElementById('settings-volume-slider');
        const settingsMuteButton = document.getElementById('settings-mute-button');
        const settingsSpeedDownButton = document.getElementById('settings-speed-down-button');
        const settingsSpeedDisplay = document.getElementById('settings-speed-display');
        const settingsSpeedUpButton = document.getElementById('settings-speed-up-button');
        const settingsTtsVoiceSelect = document.getElementById('settings-tts-voice');
        const settingsTtsRateSlider = document.getElementById('settings-tts-rate');
        const settingsTtsPitchSlider = document.getElementById('settings-tts-pitch');
        const loadGameButton = document.getElementById('load-game-button');
        const saveGameButton = document.getElementById('save-game-button');

        // --- 遊戲狀態變數 ---
        let currentChapter = 0;
        let currentStoryNodeId = null;
        let chosenCharacter = null;
        let selectedCharacterIdTemp = null;
        let collectedClues = [];
        let gameState = { sanity: 100 };
        let isMuted = false;
        let currentVolume = 0.4;
        let typewriterTimeout = null;
        let isAudioInitialized = false;
        let audioContextRequiresInteraction = true;
        const BASE_TYPEWRITER_SPEED = 55;
        let typewriterSpeed = BASE_TYPEWRITER_SPEED;
        const MAX_SPEED = 10;
        const MIN_SPEED = 100;
        const SPEED_STEP = 10;
        let availableVoices = [];
        let selectedVoice = null;
        let currentTtsRate = 0.9;
        let currentTtsPitch = 0.8;
        let currentUtterance = null;
        let lastSpokenText = "";
        let lastSpeakButton = null;
        let isSpeechPaused = false;
        let populateVoiceListAttempts = 0;
        let currentTimeOfDay = 'night';
        const SAVE_GAME_KEY = 'horrorAdventureSaveData';

        // --- 音效合成器 ---
        let sfxPlayer = null;
        let synth = null;

        // --- 恐怖驚悚關鍵字列表 ---
        const keywords = ["療養院", "病房", "走廊", "黑暗", "低語", "影子", "腳步聲", "血跡", "鑰匙", "日記", "醫生", "護士", "病人", "實驗", "逃脫", "地下室", "閣樓", "幻覺", "瘋狂", "詛咒", "儀式", "符號", "鎖鏈", "鐵窗", "鏽蝕", "冰冷", "腐朽", "尖叫", "無助", "恐懼", "真相", "消毒水", "皺巴巴的紙條", "牆裡", "鐵床"];

        // --- 角色資料 (單一主角) ---
        const characters = {
             patientX: {
                 id: 'patientX', name: '你 (病人?)',
                 avatar: 'https://images.pexels.com/photos/1886641/pexels-photo-1886641.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', // 範例圖片，建議替換
                 description: '頭痛欲裂... 你對自己是誰、為何會在這裡<span class="keyword">一無所知</span>。身上穿著骯髒的<span class="keyword">病人</span>服，唯一的感覺是徹骨的<span class="keyword">冰冷</span>和來自<span class="keyword">黑暗</span>深處的<span class="keyword">恐懼</span>。',
                 tags: ["失憶", "病人?", "恐懼", "求生"],
                 startNode: 'chapter1_start' // 遊戲開始後的第一個實際節點
             }
        };

        // --- 恐怖場景背景 (已更新為你提供的連結) ---
        const sceneBackgrounds = {
             start: 'https://t242642911.github.io/kevinboy/%E9%96%8B%E5%A7%8B%E7%95%AB%E9%9D%A2%E8%83%8C%E6%99%AF.png',
             characterSelect: 'https://placehold.co/1200x800/1a1a1a/cccccc?text=CharSelect (Optional)', // 角色選擇 (可選)
             room: 'https://t242642911.github.io/kevinboy/%E7%97%85%E6%88%BF%E8%83%8C%E6%99%AF.png',
             corridor: 'https://t242642911.github.io/kevinboy/%E8%B5%B0%E5%BB%8A%E8%83%8C%E6%99%AF.png',
             basement: 'https://placehold.co/1200x800/1a1a1a/cccccc?text=Basement (Optional)', // 地下室 (可選)
             ending: 'https://t242642911.github.io/kevinboy/%E9%80%9A%E7%94%A8%E9%8C%AF%E8%AA%A4.png'  // 預設結局/通用背景
        };

        // --- 恐怖故事劇情 (結局背景已更新為你提供的連結) ---
        const story = {
            game_start: {
                 type: 'narration', title: '第一章：甦醒', text: "劇烈的頭痛讓你從昏沉中驚醒。你發現自己躺在一張<span class=\"keyword\">冰冷</span>的<span class=\"keyword\">鐵床</span>上，四周一片<span class=\"keyword\">黑暗</span>，只有從<span class=\"keyword\">鐵窗</span>外透進來的微弱月光勾勒出房間的輪廓。空氣中瀰漫著<span class=\"keyword\">鏽蝕</span>和<span class=\"keyword\">消毒水</span>混合的怪味。這裡是... <span class=\"keyword\">療養院</span>？",
                 action: () => { chosenCharacter = characters.patientX; playerNameGame.innerHTML = highlightKeywords(chosenCharacter.name); playerAvatarGame.src = chosenCharacter.avatar; playerAvatarGame.onerror = () => { playerAvatarGame.src = 'https://placehold.co/100x100/333333/cccccc?text=?'; }; currentTimeOfDay = 'night'; updateVisualsBasedOnTime(); },
                 next: 'chapter1_start', background: sceneBackgrounds.room, objective: "檢查周圍環境"
            },
            chapter1_start: { type: 'narration', text: "你掙扎著坐起身，環顧四周。這似乎是一間廢棄的<span class=\"keyword\">病房</span>，牆皮剝落，角落裡堆著蒙塵的雜物。房門緊閉著。你的頭依然很痛，關於之前的事情<span class=\"keyword\">一無所知</span>。手邊好像碰到了什麼...", background: sceneBackgrounds.room, choices: [ { text: "摸索手邊的東西 <span title='Hand'>🖐️</span>", next: 'chapter1_find_note', sfx: 'ui_light' }, { text: "下床，試著走向房門 <span title='Walk'>🚶</span>", next: 'chapter1_goto_door', sfx: 'footstep_slow' }, { text: "走向窗戶，看看外面 <span title='Window'>🖼️</span>", next: 'chapter1_goto_window', sfx: 'creak' } ] },
            chapter1_find_note: { type: 'narration', text: "你摸到一張<span class=\"keyword\">皺巴巴的紙條</span>。藉著微弱的光線，你看到上面用顫抖的筆跡寫著：「<span class=\"keyword\">他們在牆裡...不要出聲...必須在<span class=\"keyword\">儀式</span>完成前<span class=\"keyword\">逃脫</span>...<span class=\"keyword\">鑰匙</span>在...」 字跡在這裡中斷了，沾染著暗紅色的污漬，像是<span class=\"keyword\">血跡</span>。", action: () => { addClue("找到一張紙條：提及牆裡的『他們』、儀式、逃脫和鑰匙。有血跡。"); updateGameState('foundNote', true); }, next: 'chapter1_after_note' },
            chapter1_goto_door: { type: 'narration', text: "你蹣跚地走到門邊，<span class=\"keyword\">冰冷</span>的鐵門上沒有把手，只有一個鑰匙孔和一道觀察窗，但窗戶被從外面封死了。門被<span class=\"keyword\">鎖</span>住了。", action: () => { addClue("病房門被鎖住了，需要鑰匙。"); updateGameState('checkedDoor', true); }, next: 'chapter1_after_check_door' },
            chapter1_goto_window: { type: 'narration', text: "<span class=\"keyword\">鐵窗</span>上佈滿<span class=\"keyword\">鏽蝕</span>，冰冷的風從縫隙中灌進來。窗外是死寂的黑夜，你看不到任何燈光，只能隱約看到下方似乎是荒蕪的<span class=\"keyword\">庭院</span>輪廓。這裡的高度...跳下去肯定活不了。", action: () => { addClue("窗戶被封死，外面是荒蕪的庭院，無法從此逃脫。"); }, next: 'chapter1_after_check_window' },
            chapter1_after_note: { type: 'narration', text: "這張<span class=\"keyword\">紙條</span>讓你心頭一緊。<span class=\"keyword\">牆裡</span>？<span class=\"keyword\">儀式</span>？", choices: [ { text: "試著走向房門", next: 'chapter1_goto_door', condition: () => !gameState.checkedDoor, sfx: 'footstep_slow' }, { text: "走向窗戶", next: 'chapter1_goto_window', condition: () => !gameState.checkedWindow, sfx: 'creak' }, { text: "仔細檢查房間的其他地方", next: 'chapter1_search_room', sfx: 'search' } ] },
            chapter1_after_check_door: { type: 'narration', text: "門打不開，你感到一絲<span class=\"keyword\">無助</span>。", choices: [ { text: "摸索手邊的東西", next: 'chapter1_find_note', condition: () => !gameState.foundNote, sfx: 'ui_light' }, { text: "走向窗戶", next: 'chapter1_goto_window', condition: () => !gameState.checkedWindow, sfx: 'creak' }, { text: "仔細檢查房間的其他地方", next: 'chapter1_search_room', sfx: 'search' } ] },
            chapter1_after_check_window: { type: 'narration', text: "窗外只有<span class=\"keyword\">黑暗</span>和絕望。", action: () => { updateGameState('checkedWindow', true); }, choices: [ { text: "摸索手邊的東西", next: 'chapter1_find_note', condition: () => !gameState.foundNote, sfx: 'ui_light' }, { text: "試著走向房門", next: 'chapter1_goto_door', condition: () => !gameState.checkedDoor, sfx: 'footstep_slow' }, { text: "仔細檢查房間的其他地方", next: 'chapter1_search_room', sfx: 'search' } ] },
            chapter1_search_room: { type: 'narration', text: "你在<span class=\"keyword\">黑暗</span>中摸索。床底下空無一物，牆角的櫃子是空的，只有一股<span class=\"keyword\">腐朽</span>的氣味。突然，你聽到<span class=\"keyword\">走廊</span>外傳來一陣拖沓的<span class=\"keyword\">腳步聲</span>，由遠及近...", objective: "應對走廊的聲音", choices: [ { text: "屏住呼吸，躲到床底下 <span title='Hide'>🫣</span>", next: 'chapter1_hide', sfx: 'heartbeat_fast' }, { text: "透過門上的觀察口（如果能看）向外偷看 <span title='Eye'>👁️</span>", next: 'chapter1_peek', sfx: 'ui_light' }, { text: "保持不動，聽著聲音靠近 <span title='Ear'>👂</span>", next: 'chapter1_listen', sfx: 'suspense' } ] },
            chapter1_hide: { type: 'narration', text: "你迅速鑽到<span class=\"keyword\">冰冷</span>的鐵床下，蜷縮在<span class=\"keyword\">黑暗</span>中，心臟狂跳。<span class=\"keyword\">腳步聲</span>在你的門口停了下來... 過了好一會兒，聲音又漸漸遠去了。危機暫時解除了？", action: () => { addClue("走廊外有奇怪的腳步聲經過，躲過了一劫。"); updateGameState('survivedFirstEncounter', true); }, next: 'chapter1_room_quiet_again' },
            chapter1_peek: { type: 'narration', text: "你湊到門邊，試圖透過觀察窗向外看，但它被鐵板封得死死的，什麼也看不到。外面的<span class=\"keyword\">腳步聲</span>似乎在門口徘徊了一下，然後慢慢走遠了。", action: () => { addClue("門上的觀察窗被封死。走廊外的腳步聲在門口停留後離開。"); updateGameState('survivedFirstEncounter', true); }, next: 'chapter1_room_quiet_again' },
            chapter1_listen: { type: 'narration', text: "你站在原地，<span class=\"keyword\">恐懼</span>讓你無法動彈。<span class=\"keyword\">腳步聲</span>越來越近，停在了門外。突然，門被猛烈地撞擊了一下！你嚇得後退一步。撞擊聲停了下來，過了一會，<span class=\"keyword\">腳步聲</span>才慢慢離去。", action: () => { addClue("走廊外的東西撞擊了房門！"); updateGameState('doorBanged', true); updateGameState('survivedFirstEncounter', true); }, next: 'chapter1_room_quiet_again' },
            chapter1_room_quiet_again:{ type: 'narration', text: "四周再次恢復死寂，只剩下你自己的心跳聲。看來必須想辦法離開這個<span class=\"keyword\">病房</span>。", choices: [ { text: "再次摸索床邊", next: 'chapter1_find_note', condition: () => !gameState.foundNote, sfx: 'ui_light'}, { text: "檢查枕頭下面", next: 'chapter1_check_pillow', sfx: 'search'}, { text: "撞門，試圖引起注意（危險？）", next: 'chapter1_bang_door', style:'danger', sfx: 'action'} ] }, // 添加 style:'danger'
            chapter1_check_pillow: { type: 'narration', text: "你掀開<span class=\"keyword\">冰冷</span>、沾有不明污漬的枕頭，下面似乎壓著什麼... 是一把<span class=\"keyword\">鏽蝕</span>的<span class=\"keyword\">鑰匙</span>！", action: () => { addClue("在枕頭下找到一把鏽蝕的鑰匙。"); updateGameState('hasKey', true); }, next: 'chapter1_found_key'},
            chapter1_bang_door: {type: 'narration', text: "你用力撞向<span class=\"keyword\">冰冷</span>的鐵門，發出沉悶的響聲。除了迴音，什麼也沒有... 不對，<span class=\"keyword\">走廊</span>深處似乎傳來了奇怪的<span class=\"keyword\">低語</span>...", action: () => { addClue("撞門沒有用，反而可能引來了注意。"); /*gameState.sanity -= 5;*/}, next: 'chapter1_room_quiet_again'}, // 回到之前的狀態，但可能有潛在影響
            chapter1_found_key: {type: 'narration', text: "拿到<span class=\"keyword\">鑰匙</span>讓你看到一線希望。", choices: [ { text: "用<span class=\"keyword\">鑰匙</span>打開房門", next: 'chapter2_open_door', condition:()=> gameState.hasKey, sfx: 'key_turn'}, { text: "再檢查一下房間", next: 'chapter1_room_quiet_again', sfx: 'search'} ]}, // 獲得鑰匙後

            // --- 第二章 (離開房間後) ---
            chapter2_open_door: { type: 'narration', title: "第二章：迴廊", text: "你顫抖著將<span class=\"keyword\">鑰匙</span>插入鎖孔，伴隨著「喀嚓」一聲，門鎖開了！你深吸一口氣，推開沉重的鐵門，踏入了更加<span class=\"keyword\">黑暗</span>、<span class=\"keyword\">冰冷</span>的<span class=\"keyword\">走廊</span>。", action: () => { currentChapter = 2; }, next: 'chapter2_corridor_explore', background: sceneBackgrounds.corridor, objective: "探索走廊"},
            chapter2_corridor_explore: { type: 'narration', text: "<span class=\"keyword\">走廊</span>兩側似乎有更多的<span class=\"keyword\">病房</span>門，大多緊閉著。空氣中<span class=\"keyword\">腐朽</span>的氣味更濃了，隱約能聽到難以分辨來源的<span class=\"keyword\">低語</span>聲。你需要決定往哪個方向走。", choices: [ { text: "向左邊<span class=\"keyword\">走廊</span>探索", next: 'ending_caught', sfx: 'footstep_slow'}, // 示例：直接跳結局
                         { text: "向右邊<span class=\"keyword\">走廊</span>探索", next: 'ending_madness', sfx: 'footstep_slow'}, // 示例：直接跳結局
                         { text: "返回<span class=\"keyword\">病房</span>", next: 'chapter1_room_quiet_again', sfx: 'footstep_slow'} ]}, // 可以返回房間

            // --- 結局 ---
            ending_escaped: { type: 'ending', title: "逃出生天 <span title='Run'>🎉</span>", description: "你用找到的<span class=\"keyword\">鑰匙</span>打開了<span class=\"keyword\">療養院</span>的大門，外面是微亮的黎明。你不敢回頭，拼命地跑，將身後的<span class=\"keyword\">黑暗</span>與<span class=\"keyword\">低語</span>遠遠拋下。雖然你仍不清楚這裡發生了什麼，但你活下來了...暫時。", outcome: 'success', background: 'https://t242642911.github.io/kevinboy/%E6%88%90%E5%8A%9F%E9%80%83%E8%84%AB.png' },
            ending_madness: { type: 'ending', title: "永恆<span class=\"keyword\">瘋狂</span> <span title='Dizzy'>😵‍💫</span>", description: "接二連三的<span class=\"keyword\">恐怖</span>景象和<span class=\"keyword\">幻覺</span>徹底摧毀了你的理智。你蜷縮在<span class=\"keyword\">病房</span>的角落，對著空氣<span class=\"keyword\">低語</span>，眼神空洞。你成了這座<span class=\"keyword\">療養院</span>新的<span class=\"keyword\">病人</span>，永遠無法<span class=\"keyword\">逃脫</span>。", outcome: 'fail_sanity', background: 'https://t242642911.github.io/kevinboy/%E9%99%B7%E5%85%A5%E7%98%8B%E7%8B%82.png' },
            ending_caught: { type: 'ending', title: "無處可逃 <span title='Chains'>⛓️</span>", description: "在<span class=\"keyword\">黑暗</span>的<span class=\"keyword\">走廊</span>中，你最終還是被那拖沓的<span class=\"keyword\">腳步聲</span>追上。一雙<span class=\"keyword\">冰冷</span>的手抓住了你，將你拖回無盡的<span class=\"keyword\">恐懼</span>深淵...", outcome: 'fail_caught', background: 'https://t242642911.github.io/kevinboy/%E8%A2%AB%E6%8A%93%E4%BD%8F.png' },
            ending_fail_generic: { type: 'ending', title: "迷失<span class=\"keyword\">黑暗</span> <span title='Question'>❓</span>", description: "發生了什麼...？你的意識逐漸模糊，最終被無盡的<span class=\"keyword\">黑暗</span>吞噬。也許，從一開始就沒有<span class=\"keyword\">逃脫</span>的可能。", outcome: 'error', background: 'https://t242642911.github.io/kevinboy/%E9%80%9A%E7%94%A8%E9%8C%AF%E8%AA%A4.png' }
        };

        // --- 核心函數 ---
        // [ 此處省略了所有 JavaScript 核心函數的代碼，因為它們與之前的版本相同 ]
        // [ 請確保將上一回答中從 updateVisualsBasedOnTime() 到 loadGame() 的所有函數複製到此處 ]
        function updateVisualsBasedOnTime() {
            const gameScreenElement = document.getElementById('game-screen');
            if (!gameScreenElement) return;
            const existingOverlay = gameScreenElement.querySelector('.time-overlay');
            if (existingOverlay) existingOverlay.remove();
            if (currentTimeOfDay === 'night') {
                const overlay = document.createElement('div');
                overlay.className = 'time-overlay';
                overlay.style.cssText = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(10, 10, 20, 0.4); z-index: 1; pointer-events: none; transition: background-color 0.8s ease-in-out;`; // 恐怖遊戲夜晚遮罩
                gameScreenElement.appendChild(overlay);
                console.log("應用夜晚遮罩");
            } else { // 白天可能也有不同的濾鏡或效果
                console.log("目前是白天，移除遮罩");
            }
        }

        function showScreen(screenId) {
             startScreen.classList.add('hidden');
             characterSelectScreen.classList.add('hidden'); // 恐怖遊戲可能不用這個畫面
             gameScreen.classList.add('hidden');
             endingScreen.classList.add('hidden');
             const screenToShow = document.getElementById(screenId);
             if (screenToShow) {
                 screenToShow.classList.remove('hidden');
                 let bgKey = screenId.replace('-screen', '');
                 if (screenId === 'start-screen') bgKey = 'start';
                 // else if (screenId === 'character-select-screen') bgKey = 'characterSelect'; // 如果不用選角就註釋掉
                 let backgroundUrl = sceneBackgrounds[bgKey]; // 獲取對應 key 的背景
                 // 遊戲中和結局優先使用 story node 中定義的背景
                 if (screenId === 'game-screen' && currentStoryNodeId && story[currentStoryNodeId] && story[currentStoryNodeId].background) {
                     backgroundUrl = story[currentStoryNodeId].background;
                 } else if (screenId === 'ending-screen' && currentStoryNodeId && story[currentStoryNodeId] && story[currentStoryNodeId].background) {
                    backgroundUrl = story[currentStoryNodeId].background;
                 } else if (screenId === 'ending-screen'){
                    backgroundUrl = sceneBackgrounds['ending']; // 預設結局背景
                 }
                 // 載入圖片 (使用 placeholder.co 作為備用)
                 if (backgroundUrl && (backgroundUrl.includes('.jpg') || backgroundUrl.includes('.png') || backgroundUrl.includes('.jpeg') || backgroundUrl.includes('.webp'))) {
                     const tempDiv = document.createElement('div');
                     tempDiv.style.cssText = `background-image: url('${backgroundUrl}'); background-size: cover; background-position: center; position: fixed; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; transition: opacity 0.8s ease-in-out; z-index: -1;`; // 淡入時間加長
                     document.body.appendChild(tempDiv);
                     const img = new Image();
                     img.onload = () => {
                         screenToShow.style.backgroundImage = `url('${backgroundUrl}')`;
                         screenToShow.style.backgroundSize = 'cover';
                         screenToShow.style.backgroundPosition = 'center';
                         const oldTemp = document.querySelector('.temp-bg');
                         if(oldTemp) oldTemp.remove();
                         setTimeout(() => tempDiv.style.opacity = '1', 50);
                         tempDiv.classList.add('temp-bg');
                         setTimeout(() => { if (tempDiv.parentElement) tempDiv.remove(); }, 900); // 移除時間也加長
                     };
                     img.onerror = () => {
                         console.error(`無法載入背景圖片: ${backgroundUrl}. 使用 placeholder.`);
                         screenToShow.style.backgroundImage = `url('https://placehold.co/1200x800/1a1a1a/cccccc?text=Image+Error')`; // 暗色背景錯誤圖
                         screenToShow.style.backgroundSize = 'cover';
                         screenToShow.style.backgroundPosition = 'center';
                         if (tempDiv.parentElement) tempDiv.remove();
                     }
                     img.src = backgroundUrl;
                 } else {
                    console.warn(`無效或無背景圖片 URL: ${backgroundUrl}. 使用 placeholder.`);
                    screenToShow.style.backgroundImage = `url('https://placehold.co/1200x800/1a1a1a/cccccc?text=Horror+Scene')`; // 暗色 placeholder
                    screenToShow.style.backgroundSize = 'cover';
                    screenToShow.style.backgroundPosition = 'center';
                 }
                 // 更新日夜視覺
                 if (screenId === 'game-screen') updateVisualsBasedOnTime();
                 else {
                     const gameScreenElement = document.getElementById('game-screen');
                     const existingOverlay = gameScreenElement?.querySelector('.time-overlay');
                     if (existingOverlay) existingOverlay.remove();
                 }
             } else {
                 console.error("畫面未找到:", screenId);
             }
             syncAudioControls();
             updateSpeedDisplay();
        }

        // 恐怖遊戲通常單主角，此函數可能不用或簡化
        function populateCharacterSelection() {
             characterOptionsContainer.innerHTML = '';
             selectedCharacterIdTemp = null;
             currentTimeOfDay = 'night';
             for (const charId in characters) {
                 const char = characters[charId];
                 const card = document.createElement('div');
                 card.className = 'character-card';
                 card.dataset.charId = charId;
                 let tagsHTML = '';
                 if (char.tags && char.tags.length > 0) {
                     tagsHTML = char.tags.map(tag => `<span class="keyword-tag-box">${highlightKeywords(tag, false)}</span>`).join('');
                 }
                 let avatarSrc = char.avatar;
                 card.innerHTML = `
                     <div class="character-image-container">
                         <img src="${avatarSrc}" alt="${char.name} 頭像" onerror="this.onerror=null; this.src='https://placehold.co/160x200/333333/cccccc?text=圖片載入失敗';">
                     </div>
                     <div class="character-info-container">
                         <h3>${highlightKeywords(char.name)}</h3>
                         <p class="character-description">${highlightKeywords(char.description)}</p>
                         <div class="character-tags">${tagsHTML}</div>
                         <button class="btn btn-select-char btn-danger">選擇</button> </div>`;
                 const selectButton = card.querySelector('.btn-select-char');
                 if(selectButton) {
                     selectButton.onclick = (event) => {
                         event.stopPropagation();
                         highlightCharacter(charId);
                         selectCharacter(charId);
                     };
                 }
                 card.onclick = () => highlightCharacter(charId);
                 characterOptionsContainer.appendChild(card);
             }
        }

        function highlightCharacter(charId) {
            playSFX('ui_creepy'); // 換個音效?
            selectedCharacterIdTemp = charId;
            const allCards = characterOptionsContainer.querySelectorAll('.character-card');
            allCards.forEach(card => card.classList.remove('selected'));
            const selectedCard = characterOptionsContainer.querySelector(`.character-card[data-char-id="${charId}"]`);
            if (selectedCard) selectedCard.classList.add('selected');
        }

        // 恐怖遊戲可能直接設定主角
        function selectCharacter(charId) {
            if (!charId) return;
            playSFX('confirm_creepy'); // 換個音效?
            chosenCharacter = characters[charId];
            collectedClues = [];
            gameState = { sanity: 100 }; // 初始化狀態
            currentChapter = 1;
            currentTimeOfDay = 'night';
            updateNotebook();
            let avatarSrc = chosenCharacter.avatar;
            playerAvatarGame.src = avatarSrc;
            playerAvatarGame.onerror = () => { playerAvatarGame.src = 'https://placehold.co/100x100/333333/cccccc?text=?'; };
            playerNameGame.innerHTML = highlightKeywords(chosenCharacter.name);
            loadStoryNode(chosenCharacter.startNode); // 從角色指定的節點開始
        }

        function loadStoryNode(nodeId) {
             clearTimeout(typewriterTimeout);
             if ('speechSynthesis' in window) {
                 speechSynthesis.cancel();
                 isSpeechPaused = false; lastSpokenText = ""; lastSpeakButton = null;
             }
             document.querySelectorAll('.speak-button.speaking, .speak-button.paused').forEach(btn => {
                 btn.classList.remove('speaking', 'paused'); btn.innerHTML = '🔊';
             });
             const resolvedNodeId = typeof nodeId === 'function' ? nodeId(chosenCharacter.id) : nodeId;
             const node = story[resolvedNodeId];
             if (!node) {
                 console.error("故事節點未找到:", resolvedNodeId);
                 loadStoryNode('ending_fail_generic'); // 跳轉到通用失敗結局
                 return;
             }
             currentStoryNodeId = resolvedNodeId;
             showScreen('game-screen'); // 更新背景和日夜
             // 更新標題和目標
             if (node.title) chapterTitle.innerHTML = highlightKeywords(node.title);
             else if (resolvedNodeId.includes('intro') || resolvedNodeId.includes('start')) { // 擴大判斷範圍
                const nodeTextContent = getTextFromNode(node, false);
                const titleMatch = nodeTextContent.match(/^(.+?)(\n|$)/); // 匹配第一行
                if (titleMatch && titleMatch[1].trim()) chapterTitle.innerHTML = highlightKeywords(titleMatch[1].trim());
                else chapterTitle.innerHTML = ""; // 如果沒有標題則清空
             } else {
                 chapterTitle.innerHTML = ""; // 默認清空章節標題，除非節點特別指定
             }
             if(node.objective) currentObjective.textContent = `目標: ${node.objective}`;
             else currentObjective.textContent = `目標: 生存下去...`; // 預設目標
             chapterTitle.classList.add('chapter-title-style');
             if (node.action) node.action();
             if (node.type === 'narration' || node.type === 'dialogue') displayMessage(node);
             else if (node.type === 'ending') { displayEnding(node); return; }
             else displayChoices(node); // 處理只有選項的節點
        }

        function highlightKeywords(text, isChoice = false) {
            if (!text) return '';
            let highlightedText = text;
            const keywordClass = isChoice ? 'choice-keyword' : 'keyword';
            const regex = new RegExp(`(${keywords.join('|')})`, 'g');
            highlightedText = highlightedText.replace(regex, `<span class="${keywordClass}">$1</span>`);
            return highlightedText;
        }

        function getTextFromNode(node, applyHighlight = true, isChoice = false) {
            let rawText = '';
            if (typeof node.text === 'function') rawText = node.text(chosenCharacter ? chosenCharacter.name : '');
            else rawText = node.text || '';
            return applyHighlight ? highlightKeywords(rawText, isChoice) : rawText;
        }

        function displayMessage(node) {
            const messageHTML = getTextFromNode(node, true, false);
            const messageElement = document.createElement('div');
            messageElement.className = 'dialogue-box fade-in';
            let characterName = "旁白";
            const nameElement = document.createElement('div');
            nameElement.className = 'character-name';
            let rawTextForSpeech = getTextFromNode(node, false);
            if (node.type === 'dialogue') {
                characterName = node.character;
                const highlightedCharName = highlightKeywords(characterName, false);
                 if (characterName === '你' || (chosenCharacter && characterName === chosenCharacter.name)) {
                     messageElement.classList.remove('npc');
                     messageElement.classList.add('player');
                 } else {
                      messageElement.classList.add('npc');
                 }
                nameElement.innerHTML = highlightedCharName + ":";
                messageElement.appendChild(nameElement);
                rawTextForSpeech = rawTextForSpeech.replace(/^（.*?）/, '').trim();
            } else {
                messageElement.classList.add('italic', 'npc');
            }
            const plainText = rawTextForSpeech.replace(/<[^>]*>/g, '');
             const emojiRegex = /[\u{1F300}-\u{1F5FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F900}-\u{1F9FF}\u{1FA70}-\u{1FAFF}]/gu;
             let textToSpeak = plainText.replace(emojiRegex, '').replace(/\s+/g, ' ').trim();
            const textSpan = document.createElement('span');
            messageElement.appendChild(textSpan);
            if ('speechSynthesis' in window && textToSpeak) {
                const speakButton = document.createElement('button');
                speakButton.className = 'speak-button'; speakButton.innerHTML = '🔊';
                speakButton.title = '播放聲音'; speakButton.dataset.textToSpeak = textToSpeak;
                speakButton.onclick = (e) => {
                    e.stopPropagation();
                    const text = e.currentTarget.dataset.textToSpeak;
                    const synth = window.speechSynthesis;
                    if (synth.speaking) {
                        if (synth.paused && currentUtterance && currentUtterance.text === text) { synth.resume(); e.currentTarget.classList.remove('paused'); e.currentTarget.classList.add('speaking'); e.currentTarget.innerHTML = '🔊'; isSpeechPaused = false; }
                        else if (currentUtterance && currentUtterance.text === text) { synth.pause(); e.currentTarget.classList.add('paused'); e.currentTarget.classList.remove('speaking'); e.currentTarget.innerHTML = '⏸️'; isSpeechPaused = true; }
                        else { document.querySelectorAll('.speak-button.speaking, .speak-button.paused').forEach(btn => { if (btn !== e.currentTarget) { btn.classList.remove('speaking', 'paused'); btn.innerHTML = '🔊'; } }); speakText(text, e.currentTarget); e.currentTarget.classList.remove('paused'); e.currentTarget.classList.add('speaking'); e.currentTarget.innerHTML = '🔊'; isSpeechPaused = false; }
                    } else { document.querySelectorAll('.speak-button.speaking, .speak-button.paused').forEach(btn => { if (btn !== e.currentTarget) { btn.classList.remove('speaking', 'paused'); btn.innerHTML = '🔊'; } }); speakText(text, e.currentTarget); e.currentTarget.classList.remove('paused'); e.currentTarget.classList.add('speaking'); e.currentTarget.innerHTML = '🔊'; isSpeechPaused = false; }
                };
                messageElement.appendChild(speakButton);
            }
            storyDisplay.appendChild(messageElement);
            let charIndex = 0; let visibleHTML = '';
            function typeWriterAdvanced() {
                if (charIndex < messageHTML.length) {
                    const char = messageHTML[charIndex]; let shouldDelay = true;
                    if (char === '<') { const tagMatch = messageHTML.substring(charIndex).match(/^<[^>]+>/); if (tagMatch) { visibleHTML += tagMatch[0]; charIndex += tagMatch[0].length; shouldDelay = false; } else { visibleHTML += char; charIndex++; } }
                    else { visibleHTML += char; charIndex++; }
                    textSpan.innerHTML = visibleHTML;
                    if (shouldDelay) typewriterTimeout = setTimeout(typeWriterAdvanced, typewriterSpeed);
                    else typeWriterAdvanced();
                    storyDisplay.scrollTop = storyDisplay.scrollHeight;
                } else { displayChoices(node); storyDisplay.scrollTop = storyDisplay.scrollHeight; }
            }
            choicesDisplay.innerHTML = ''; disableChoices(); typeWriterAdvanced();
        }

        function displayChoices(node) {
             choicesDisplay.innerHTML = '';
             if (node.choices && node.choices.length > 0) {
                 let hasVisibleChoice = false;
                 node.choices.forEach(choice => {
                     let conditionMet = true; if (choice.condition) conditionMet = choice.condition(chosenCharacter ? chosenCharacter.id : null, gameState);
                     if (conditionMet) {
                         hasVisibleChoice = true; const button = document.createElement('button');
                         button.className = 'btn block w-full md:w-auto md:inline-block my-1 fade-in';
                         if (choice.style === 'danger') button.classList.add('btn-danger');
                         else button.classList.add('btn-secondary');
                         button.style.opacity = '0';
                         const buttonText = typeof choice.text === 'function' ? choice.text() : choice.text; button.innerHTML = highlightKeywords(buttonText, true);
                         button.onclick = () => { if ('speechSynthesis' in window) { speechSynthesis.cancel(); isSpeechPaused = false; } playSFX(choice.sfx || 'ui_creepy'); if (choice.action) choice.action(); disableChoices(); loadStoryNode(choice.next); };
                         choicesDisplay.appendChild(button);
                     }
                 });
                 if (hasVisibleChoice) setTimeout(() => { choicesDisplay.querySelectorAll('.btn').forEach(btn => btn.style.opacity = '1'); }, 50);
             } else if (node.next && node.type !== 'ending') {
                 const continueButton = document.createElement('button'); continueButton.className = 'btn block w-full md:w-auto md:inline-block my-1 fade-in btn-secondary'; continueButton.style.opacity = '0'; continueButton.textContent = "繼續探索...";
                 continueButton.onclick = () => { if ('speechSynthesis' in window) { speechSynthesis.cancel(); isSpeechPaused = false; } playSFX('footstep_slow'); disableChoices(); loadStoryNode(node.next); };
                 choicesDisplay.appendChild(continueButton); setTimeout(() => continueButton.style.opacity = '1', 50);
             }
             storyDisplay.scrollTop = storyDisplay.scrollHeight;
        }

        function disableChoices() { choicesDisplay.querySelectorAll('button').forEach(button => { button.disabled = true; button.classList.add('btn-disabled'); }); }
        function displayEnding(node) { playSFX('ending_horror'); endingTitle.innerHTML = highlightKeywords(node.title, false); endingDescription.innerHTML = highlightKeywords(node.description, false); showScreen('ending-screen'); }
        function addClue(clueText) { const plainClueText = clueText.replace(/<[^>]*>/g, ''); const plainCollectedClues = collectedClues.map(c => c.replace(/<[^>]*>/g, '')); if (!plainCollectedClues.includes(plainClueText)) { collectedClues.push(clueText); updateNotebook(); playSFX('discover_creepy'); } }
        function hasClue(clueSubstring) { const plainClues = collectedClues.map(clue => clue.replace(/<[^>]*>/g, '')); return plainClues.some(clue => clue.includes(clueSubstring)); }
        function updateGameState(key, value) { gameState[key] = value; console.log("GameState updated:", key, "=", value); }
        function updateNotebook() { clueList.innerHTML = ''; if (collectedClues.length === 0) clueList.innerHTML = '<li>這裡<span class="keyword">空空如也</span>...</li>'; else collectedClues.forEach(clue => { const li = document.createElement('li'); li.innerHTML = highlightKeywords(clue, false); clueList.appendChild(li); }); }
        function openNotebook() { playSFX('paper_crinkle'); notebookModal.classList.add('active'); }
        function closeNotebook() { playSFX('ui_close_soft'); notebookModal.classList.remove('active'); }
        function openSettings() { playSFX('ui_creepy'); settingsModal.classList.add('active'); syncAudioControls(); }
        function closeSettings() { playSFX('ui_close_soft'); settingsModal.classList.remove('active'); }

        async function initializeAudio() { console.log("[Audio] initializeAudio entered."); if (isAudioInitialized && Tone.context && Tone.context.state === 'running') return true; if (typeof Tone === 'undefined') { console.error("[Audio] Tone.js undefined!"); isAudioInitialized = false; return false; } if (typeof speechSynthesis === 'undefined') console.warn("[Audio] Speech Synthesis not supported."); if (Tone.context && Tone.context.state !== 'running') { console.log("[Audio] Context exists but not running, resuming..."); try { await Tone.context.resume(); console.log("[Audio] Context resumed."); audioContextRequiresInteraction = false; isAudioInitialized = true; setVolume(currentVolume); if ('speechSynthesis' in window) speechSynthesis.cancel(); Tone.Destination.mute = isMuted; return true; } catch (resumeError) { console.error("[Audio] Failed to resume context:", resumeError); } } console.log("[Audio] Attempting Tone.start()..."); try { await Tone.start(); console.log("[Audio] Tone.start() successful."); audioContextRequiresInteraction = false; isAudioInitialized = true; ensureAudioObjects(); setVolume(currentVolume); if ('speechSynthesis' in window) speechSynthesis.cancel(); Tone.Destination.mute = isMuted; return true; } catch (startError) { console.error("[Audio] Failed Tone.start():", startError); isAudioInitialized = false; audioContextRequiresInteraction = true; return false; } }
        function ensureAudioObjects() { if (!synth && isAudioInitialized && Tone.context.state === 'running') { try { console.log("[Audio] Creating Synth..."); synth = new Tone.AMSynth({ harmonicity: 1.5, modulationIndex: 1.2, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }, modulationEnvelope: { attack: 0.05, decay: 0.01, sustain: 1, release: 0.5 } }).toDestination(); console.log("[Audio] Synth created."); } catch (e) { console.error("[Audio] Error creating Synth:", e); return false; } } if (Tone.Transport && Tone.Transport.state !== 'started' && isAudioInitialized) { try { Tone.Transport.start(); console.log("[Audio] Transport started."); } catch (e) { console.error("[Audio] Error starting Transport:", e); } } return !!synth; }
        function playSFX(type) { if (isMuted || !isAudioInitialized) return; if (!ensureAudioObjects() || !synth) { console.error("Cannot play SFX: Audio objects not ready."); return; } try { const now = Tone.now(); switch (type) { case 'ui_light': synth.triggerAttackRelease("C#5", "32n", now); break; case 'footstep_slow': synth.triggerAttackRelease("C2", "8n", now, 0.3); break; case 'creak': synth.triggerAttackRelease("A#3", "4n", now + 0.1); synth.triggerAttackRelease("A3", "4n", now, 0.4); break; case 'paper_crinkle': synth.triggerAttackRelease("G#5", "16n", now, 0.2); synth.triggerAttackRelease("A5", "16n", now + 0.05, 0.2); break; case 'door_locked_rattle': synth.triggerAttackRelease("D2", "16n", now, 0.5); synth.triggerAttackRelease("D#2", "16n", now + 0.1, 0.5); break; case 'wind_howling_soft': synth.triggerAttackRelease("F3", "1n", now, 0.1); break; case 'search': synth.triggerAttackRelease("E4", "16n", now, 0.2); synth.triggerAttackRelease("F#4", "16n", now + 0.15, 0.1); break; case 'footsteps_dragging_slow': synth.triggerAttackRelease("A1", "4n", now, 0.4); synth.triggerAttackRelease("A#1", "4n", now+0.5, 0.3); break; case 'heartbeat_fast': synth.triggerAttackRelease("C3", "16n", now); synth.triggerAttackRelease("C3", "16n", now + 0.2); synth.triggerAttackRelease("C3", "16n", now + 0.4); break; case 'suspense': synth.triggerAttackRelease("A2", "2n", now, 0.2); break; case 'door_bang_loud': synth.triggerAttackRelease("G1", "8n", now, 0.9); synth.triggerAttackRelease("G#1", "8n", now + 0.05, 0.8); break; case 'footsteps_fade_away': synth.triggerAttackRelease("C2", "8n", now, 0.3); synth.triggerAttackRelease("C2", "16n", now + 0.6, 0.1); break; case 'ui_creepy': synth.triggerAttackRelease("B4", "16n", now, 0.4); break; case 'confirm_creepy': synth.triggerAttackRelease("G#4", "8n", now, 0.5); break; case 'discover_creepy': synth.triggerAttackRelease("D#5", "8n", now + 0.1, 0.3); synth.triggerAttackRelease("D5", "8n", now, 0.3); break; case 'ui_close_soft': synth.triggerAttackRelease("A4", "32n", now, 0.2); break; case 'ending_horror': synth.triggerAttackRelease("F#2", "1n", now, 0.6); synth.triggerAttackRelease("G2", "1n", now + 0.1, 0.5); break; case 'key_turn': synth.triggerAttackRelease("C5", "8n", now, 0.6); break; /* 鑰匙轉動聲 */ case 'click': synth.triggerAttackRelease("C4", "32n", now, 0.3); break; case 'confirm': synth.triggerAttackRelease("E4", "16n", now, 0.4); break; default: synth.triggerAttackRelease("C4", "32n", now, 0.3); } } catch (e) { console.error("SFX error:", type, e); } }

        function speakText(textToSpeak, buttonElement = null) { if (!('speechSynthesis' in window)) return; if (!textToSpeak || isMuted) return; console.log("朗讀:", textToSpeak); speechSynthesis.cancel(); currentUtterance = new SpeechSynthesisUtterance(textToSpeak); currentUtterance.lang = selectedVoice ? selectedVoice.lang : 'zh-CN'; currentUtterance.voice = selectedVoice; currentUtterance.rate = currentTtsRate; currentUtterance.pitch = currentTtsPitch; lastSpokenText = textToSpeak; lastSpeakButton = buttonElement; isSpeechPaused = false; currentUtterance.onend = () => { console.log("朗讀結束"); if (lastSpeakButton) { lastSpeakButton.classList.remove('speaking', 'paused'); lastSpeakButton.innerHTML = '🔊'; } currentUtterance = null; lastSpokenText = ""; lastSpeakButton = null; }; currentUtterance.onerror = (event) => { console.error("朗讀錯誤:", event.error); if (lastSpeakButton) { lastSpeakButton.classList.remove('speaking', 'paused'); lastSpeakButton.innerHTML = '🔊'; } currentUtterance = null; lastSpokenText = ""; lastSpeakButton = null; }; speechSynthesis.speak(currentUtterance); }
        function populateVoiceList(attempt = 1) { if (!('speechSynthesis' in window)) return; availableVoices = speechSynthesis.getVoices(); if (availableVoices.length === 0 && attempt <= 5) { setTimeout(() => populateVoiceList(attempt + 1), 100 * attempt); return; } console.log("Available voices:", availableVoices); populateVoiceListAttempts = 0; settingsTtsVoiceSelect.innerHTML = ''; const currentSelectedName = selectedVoice ? selectedVoice.name : null; let foundSelected = false; const chineseVoices = availableVoices.filter(voice => voice.lang.startsWith('zh')); if (chineseVoices.length > 0) { chineseVoices.forEach((voice, index) => { const option = document.createElement('option'); let displayName = voice.name.replace(/Microsoft |Google | \(Online\)| \(Local\)| Taiwan| Chinese \(Taiwan\)| Chinese \(Traditional, Taiwan\)| Chinese \(Simplified, China\)| Chinese/g, '').trim(); if (!displayName) displayName = `語音 ${index + 1}`; option.textContent = `${displayName} (${voice.lang})`; option.setAttribute('data-lang', voice.lang); option.setAttribute('data-name', voice.name); if (currentSelectedName === voice.name) { option.selected = true; selectedVoice = voice; foundSelected = true; } else if (!currentSelectedName && !foundSelected && (voice.lang === 'zh-CN' || voice.lang === 'zh-TW')) { option.selected = true; selectedVoice = voice; foundSelected = true; } settingsTtsVoiceSelect.appendChild(option); }); if (!settingsTtsVoiceSelect.querySelector('option[selected]') && settingsTtsVoiceSelect.options.length > 0) { settingsTtsVoiceSelect.selectedIndex = 0; const firstVoiceName = settingsTtsVoiceSelect.options[0].getAttribute('data-name'); selectedVoice = availableVoices.find(v => v.name === firstVoiceName); console.log("Defaulting to first voice:", selectedVoice); } } else { const option = document.createElement('option'); option.textContent = '無可用中文語音'; option.disabled = true; settingsTtsVoiceSelect.appendChild(option); selectedVoice = null; } syncVoiceSelection(); }
        if ('speechSynthesis' in window && speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = populateVoiceList;
        function syncVoiceSelection() { if (!selectedVoice) { settingsTtsVoiceSelect.selectedIndex = -1; return; } let found = false; for (let i = 0; i < settingsTtsVoiceSelect.options.length; i++) { if (settingsTtsVoiceSelect.options[i].getAttribute('data-name') === selectedVoice.name) { settingsTtsVoiceSelect.selectedIndex = i; found = true; break; } } if (!found && settingsTtsVoiceSelect.options.length > 0 && !settingsTtsVoiceSelect.options[0].disabled) { settingsTtsVoiceSelect.selectedIndex = 0; const firstVoiceName = settingsTtsVoiceSelect.options[0].getAttribute('data-name'); selectedVoice = availableVoices.find(v => v.name === firstVoiceName); console.warn("Selected voice not found, defaulting."); } else if (!found) selectedVoice = null; }
        function syncRateSelection() { settingsTtsRateSlider.value = currentTtsRate; } function syncPitchSelection() { settingsTtsPitchSlider.value = currentTtsPitch; }

        function toggleMute() { isMuted = !isMuted; if (isAudioInitialized && Tone.Destination) Tone.Destination.mute = isMuted; updateMuteButtons(); if (isMuted && 'speechSynthesis' in window) { speechSynthesis.cancel(); isSpeechPaused = false; document.querySelectorAll('.speak-button.speaking, .speak-button.paused').forEach(btn => { btn.classList.remove('speaking', 'paused'); btn.innerHTML = '🔊'; }); } }
        function updateMuteButtons() { settingsMuteButton.textContent = isMuted ? "取消靜音" : "靜音"; }
        function setVolume(value) { const newVolume = parseFloat(value); currentVolume = newVolume; if (isAudioInitialized && Tone.Destination && !isMuted) Tone.Destination.volume.value = (newVolume === 0) ? -Infinity : Tone.gainToDb(newVolume); settingsVolumeSlider.value = newVolume; }
        function syncAudioControls() { settingsVolumeSlider.value = currentVolume; updateMuteButtons(); if (isAudioInitialized && Tone.Destination) { Tone.Destination.mute = isMuted; if (!isMuted) setVolume(currentVolume); } syncVoiceSelection(); syncRateSelection(); syncPitchSelection(); }
        function updateSpeedDisplay() { const speedMultiplier = (BASE_TYPEWRITER_SPEED / typewriterSpeed).toFixed(1); settingsSpeedDisplay.textContent = `x${speedMultiplier}`; }
        function increaseSpeed() { typewriterSpeed = Math.max(MAX_SPEED, typewriterSpeed - SPEED_STEP); updateSpeedDisplay(); playSFX('ui_creepy'); }
        function decreaseSpeed() { typewriterSpeed = Math.min(MIN_SPEED, typewriterSpeed + SPEED_STEP); updateSpeedDisplay(); playSFX('ui_creepy'); }

        function saveGame() { if (!chosenCharacter || !currentStoryNodeId) { alert("記憶模糊...無法保存。"); playSFX('ui_close_soft'); return; } const voiceNameToSave = selectedVoice ? selectedVoice.name : null; const saveData = { chosenCharacterId: chosenCharacter.id, currentChapter: currentChapter, currentStoryNodeId: currentStoryNodeId, collectedClues: collectedClues, gameState: gameState, currentTimeOfDay: currentTimeOfDay, currentVolume: currentVolume, isMuted: isMuted, typewriterSpeed: typewriterSpeed, selectedVoiceName: voiceNameToSave, currentTtsRate: currentTtsRate, currentTtsPitch: currentTtsPitch, currentObjectiveText: currentObjective.textContent }; try { localStorage.setItem(SAVE_GAME_KEY, JSON.stringify(saveData)); alert("記憶已保存..."); playSFX('confirm_creepy'); } catch (error) { console.error("保存失敗:", error); alert("記憶保存失敗！"); playSFX('ui_close_soft'); } }
        async function loadGame() { const savedDataString = localStorage.getItem(SAVE_GAME_KEY); if (!savedDataString) { alert("沒有可讀取的記憶..."); playSFX('ui_close_soft'); return; } try { const savedData = JSON.parse(savedDataString); console.log("讀取記憶:", savedData); chosenCharacter = characters[savedData.chosenCharacterId]; currentChapter = savedData.currentChapter ?? 1; currentStoryNodeId = savedData.currentStoryNodeId; collectedClues = savedData.collectedClues || []; gameState = savedData.gameState || { sanity: 100 }; currentTimeOfDay = savedData.currentTimeOfDay || 'night'; if (!chosenCharacter || !currentStoryNodeId) throw new Error("記憶碎片不完整。"); currentVolume = savedData.currentVolume ?? 0.4; isMuted = savedData.isMuted ?? false; typewriterSpeed = savedData.typewriterSpeed ?? BASE_TYPEWRITER_SPEED; currentTtsRate = savedData.currentTtsRate ?? 0.9; currentTtsPitch = savedData.currentTtsPitch ?? 0.8; const savedVoiceName = savedData.selectedVoiceName; if (savedVoiceName) { if (availableVoices.length > 0) { selectedVoice = availableVoices.find(v => v.name === savedVoiceName); if (!selectedVoice) console.warn(`找不到語音: ${savedVoiceName}`); } else console.warn("語音列表未載入，稍後同步。"); } else selectedVoice = null; let avatarSrc = chosenCharacter.avatar; playerAvatarGame.src = avatarSrc; playerAvatarGame.onerror = () => { playerAvatarGame.src = 'https://placehold.co/100x100/333333/cccccc?text=?'; }; playerNameGame.innerHTML = highlightKeywords(chosenCharacter.name); currentObjective.textContent = savedData.currentObjectiveText || '目標: 生存下去...'; updateNotebook(); syncAudioControls(); updateSpeedDisplay(); if (!isAudioInitialized) { console.log("音訊未初始化，嘗試啟動..."); const audioReady = await initializeAudio(); if (!audioReady) console.warn("音訊初始化失敗。"); else { setVolume(currentVolume); if (Tone.Destination) Tone.Destination.mute = isMuted; syncVoiceSelection(); } } else { setVolume(currentVolume); if (Tone.Destination) Tone.Destination.mute = isMuted; syncVoiceSelection(); } storyDisplay.innerHTML = ''; const node = story[currentStoryNodeId]; if (node) { showScreen('game-screen'); choicesDisplay.innerHTML = ''; displayMessage(node); } else throw new Error(`找不到記憶節點: ${currentStoryNodeId}`); playSFX('confirm_creepy'); alert("記憶已載入..."); } catch (error) { console.error("讀取失敗:", error); alert(`記憶讀取失敗：${error.message}`); localStorage.removeItem(SAVE_GAME_KEY); loadGameButton.classList.add('hidden'); showScreen('start-screen'); playSFX('ui_close_soft'); } }

        // --- 事件監聽器 ---
        startGameButton.addEventListener('click', async () => { console.log("掙扎醒來"); if (typeof Tone === 'undefined' || typeof speechSynthesis === 'undefined') { alert("初始化失敗！"); return; } const audioReady = await initializeAudio(); if (audioReady) { playSFX('confirm_creepy'); populateVoiceList(); } else alert("音訊初始化失敗！"); loadStoryNode('game_start'); }); // 直接開始遊戲
        restartButton.addEventListener('click', () => { playSFX('ui_creepy'); if (localStorage.getItem(SAVE_GAME_KEY)) { if (confirm("重新開始將抹去所有記憶，確定嗎？")) { localStorage.removeItem(SAVE_GAME_KEY); loadGameButton.classList.add('hidden'); } else return; } showScreen('start-screen'); currentChapter = 0; currentStoryNodeId = null; chosenCharacter = null; collectedClues = []; gameState = { sanity: 100 }; currentTimeOfDay = 'night'; selectedCharacterIdTemp = null; storyDisplay.innerHTML = ''; choicesDisplay.innerHTML = ''; updateNotebook(); typewriterSpeed = BASE_TYPEWRITER_SPEED; updateSpeedDisplay(); if ('speechSynthesis' in window) { speechSynthesis.cancel(); isSpeechPaused = false; } });
        notebookButton.addEventListener('click', openNotebook);
        openSettingsButton.addEventListener('click', openSettings);
        saveGameButton.addEventListener('click', saveGame);
        loadGameButton.addEventListener('click', loadGame);
        settingsVolumeSlider.addEventListener('input', (event) => setVolume(event.target.value));
        settingsMuteButton.addEventListener('click', toggleMute);
        settingsSpeedUpButton.addEventListener('click', increaseSpeed);
        settingsSpeedDownButton.addEventListener('click', decreaseSpeed);
        settingsTtsVoiceSelect.addEventListener('change', (event) => { const selectedOption = event.target.options[event.target.selectedIndex]; if (selectedOption && !selectedOption.disabled) { const voiceName = selectedOption.getAttribute('data-name'); selectedVoice = availableVoices.find(voice => voice.name === voiceName); syncVoiceSelection(); if ((speechSynthesis.speaking || speechSynthesis.paused) && currentUtterance && lastSpokenText && lastSpeakButton) { speakText(lastSpokenText, lastSpeakButton); lastSpeakButton.classList.remove('paused'); lastSpeakButton.classList.add('speaking'); lastSpeakButton.innerHTML = '🔊'; } } });
        settingsTtsRateSlider.addEventListener('input', (event) => { currentTtsRate = parseFloat(event.target.value); syncRateSelection(); if ((speechSynthesis.speaking || speechSynthesis.paused) && currentUtterance && lastSpokenText && lastSpeakButton) { speakText(lastSpokenText, lastSpeakButton); lastSpeakButton.classList.remove('paused'); lastSpeakButton.classList.add('speaking'); lastSpeakButton.innerHTML = '🔊'; } });
        settingsTtsPitchSlider.addEventListener('input', (event) => { currentTtsPitch = parseFloat(event.target.value); syncPitchSelection(); if ((speechSynthesis.speaking || speechSynthesis.paused) && currentUtterance && lastSpokenText && lastSpeakButton) { speakText(lastSpokenText, lastSpeakButton); lastSpeakButton.classList.remove('paused'); lastSpeakButton.classList.add('speaking'); lastSpeakButton.innerHTML = '🔊'; } });

        // --- 初始設定 ---
        showScreen('start-screen');
        if (localStorage.getItem(SAVE_GAME_KEY)) loadGameButton.classList.remove('hidden'); else loadGameButton.classList.add('hidden');
        syncAudioControls(); updateSpeedDisplay(); populateVoiceList();
        window.onclick = function(event) { if (event.target == notebookModal) closeNotebook(); if (event.target == settingsModal) closeSettings(); }

    </script>
</body>
</html>